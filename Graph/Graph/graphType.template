#include "graphType.h"
#ifndef GRAPHTEMPLATE
#define GRAPHTEMPLATE

template <class VertexType, class EdgeValueType>
GraphType<VertexType, EdgeValueType>::GraphType()
// Constructor
// Pre:	 None
// Post: GraphType is intialized, numVertices set to zero
{
	numVertices = 0;

	// vertices does not need to be initialized since we are storing numVertices

	for (int i = 0; i < MAX_VERTICES; i++) {
		for (int j = 0; j < MAX_VERTICES; j++) {
			edges[i][j] = (EdgeValueType)(0);
		}
	}

	for (int i = 0; i < MAX_VERTICES; i++)
		marks[i] = false;
}

template <class VertexType, class EdgeValueType>
GraphType<VertexType, EdgeValueType>::~GraphType()
// Deconstructor
// Pre:	 GraphType is initialized
// Post: deletes vertices, edges
{
	for (int i = 0; i < MAX_VERTICES; i++)
		delete [] edges[i];

	delete [] edges;
	delete [] vetices;
	delete [] marks;
}

template <class VertexType, class EdgeValueType>
GraphType<VertexType, EdgeValueType>::GraphType(const GraphType<VertexType, EdgeValueType>& acopy)
// Copy constructor
// Pre:	 GraphType is initialized
// Post: Graph is initialized with values from acopy
{
	numVertices = acopy.numVertices

	for (int i = 0; i < MAX_VERTICES; i++)
		vertices[i] = acopy.vertices[i];

	for (int i = 0; i < MAX_VERTICES; i++) {
		for (int j = 0; j < MAX_VERTICES; j++) {
			edges[i][j] = acopy.edges[i][j];
		}
	}

	for (int i = 0; i < MAX_VERTICES; i++)
		marks[i] = acopy.marks[i];
}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::MakeEmpty()
// Function: Initializes the graph to an empty state
// Pre:		 GraphType is initialized
// Post:	 marks, vertices, edges are empty, numVertices is zero
{
	numVertices = 0;

	// vertices does not need to be initialized since we are storing numVertices

	for (int i = 0; i < MAX_VERTICES; i++) {
		for (int j = 0; j < MAX_VERTICES; j++) {
			edges[i][j] = (EdgeValueType)(0);
		}
	}

	for (int i = 0; i < MAX_VERTICES; i++)
		marks[i] = false;
}

template <class VertexType, class EdgeValueType>
bool GraphType<VertexType, EdgeValueType>::IsEmpty()
// Function: Tests whether the graph is empty
// Pre:		 GraphType is initialized
// Post:	 Function value = (graph is empty)
{
	return (numVertices == 0);
}

template <class VertexType, class EdgeValueType>
bool GraphType<VertexType, EdgeValueType>::IsFull()
// Function: Tests whether the graph is full
// Pre:		 GraphType is initialized
// Post:	 Function value = (graph is full)
{
	return (numVertices == MAX_VERTICES);
}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::AddVertex(VertexType vertex)
// Function: Adds vertex to the graph
// Pre:		 GraphType is initialized, Graph is not full
// Post:	 vertex is in vertices, numVertices is incremented
{
	vertices[numVertices++] = vertex;
}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::AddEdge(VertexType fromVertex, VertexType toVertex, EdgeValueType weight)
// Function: Adds an edge with the specified weight from fromVertex to toVertex
// Pre:		 GraphType is initialized, fromVertex and toVertex are in vertices
// Post:	 (fromVertex, toVertex) is in edges with the specified weight
{
	edges[Search(fromVertex)][Search(toVertex)] = weight;
}

template <class VertexType, class EdgeValueType>
EdgeValueType GraphType<VertexType, EdgeValueType>::GetWeight(VertexType fromVertex, VertexType toVertex)
// Function: Returns the weight of the edge from fromVertex to toVertex
// Pre:		 GraphType is initialized, fromVertex and toVertex are vertices
// Post:	 Function value = weight of edge from fromVertex to toVertex if edge exists, if edge does not exist function value = special "null-edge" value
{
	return edges[Search(fromVertex)][Search(toVertex)];
}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::GetToVertices(VertexType vertex, QueType& vertexQ)
// Function: Returns a queue of the vertices that are adjacent from vertex
// Pre:		 GraphType is initialized, vertex is in vertices
// Post:	 vertexQ contains the names of all vertices that are adjacent from vertex
{
	for (int i = 0; i < numVertices; i++)
		vertexQ.EnQueue
		Search(vertex) 
}

template <class VertexType, class EdgeValueType>
int GraphType<VertexType, EdgeValueType>::Search(VertexType vertex)
// Function: Returns the index for a vertex in the graph
// Pre:		 GraphType is initialized
// Post:	 if found Function value = (index of vertex), otherwise throw NotFound exception
{

}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::DeleteVertex(VertexType vertex)
// Function: Deletes vertex from graph and associated edges
// Pre:		 GraphType is initialized
// Post:	 vertices does not contain vertex and numVertices is decremented, NotFound exception thrown if vertex is not in vertices before function call
{

}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::DeleteEdge(VertexType fromVertex, VertexType toVertex)
// Function: Deletes edge between fromVertex and toVertex
// Pre:		 GraphType is initialized
// Post:	 edges does not contain edge, NotFound exception thrown if edge is not in edges before function call
{

}

template <class VertexType, class EdgeValueType>
int GraphType<VertexType, EdgeValueType>::GetVerticesCount()
// Function: Gets the number of vertices in the graph
// Pre:		 GraphType is initialized
// Post:	 Function return = (numVertices)
{

}

template <class VertexType, class EdgeValueType>
bool GraphType<VertexType, EdgeValueType>::IsConnected()
// Function: Determines if the graph is connected
// Pre:		 GraphType is initialized
// Post:	 Function value = (is graph connected)
{

}

template <class VertexType, class EdgeValueType>
QueueType<EdgeType> GraphType<VertexType, EdgeValueType>::ShortestPath(VertexType fromVertex, VertexType toVertex)
// Function: Finds the shortest path between two vertices
// Pre:		 GraphType is intialized
// Post:	 Function value = (queue containing edges of shortest path)
{

}

template <class VertexType, class EdgeValueType>
GraphType<VertexType, EdgeValueType> GraphType<VertexType, EdgeValueType>::FindMinimalSpanningTree()
// Function: Finds the subgraph of the graph containing the shortest paths between the vertices
// Pre:		 GraphType is intialized
// Post:	 Function value = (graph describing minimal spanning tree)
{

}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::ClearMarks()
// Function: Sets marks for all vertices to false
// Pre:		 GraphType is initialized
// Post:	 All marks have been set to false
{

}

template <class VertexType, class EdgeValueType>
void GraphType<VertexType, EdgeValueType>::MarkVertex(VertexType vertex)
// Function: Sets mark for vertex to true
// Pre:		 vertex is in vertices
// Post:	 IsMarked(vertex) is true
{

}

template <class VertexType, class EdgeValueType>
bool GraphType<VertexType, EdgeValueType>::IsMarked(VertexType vertex)
// Function: Determines if vertex has been marked
// Pre:		 vertex is in vertices
// Post:	 Function value = (vertex is marked true)
{

}

#endif