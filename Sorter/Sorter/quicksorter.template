#ifndef QUICKSORTERTEMPLATE
#define QUICKSORTERTEMPLATE

#include "quicksorter.h"

template <class ItemType>
// Constructor
QuickSorter<ItemType>::QuickSorter(ItemType* items, int size)
{
	//int size = sizeof(items) + 1; // WHY IS THIS WRONG SIZE SHOULD BE 3 NOT 5
	arraySize = size;
	data = new ItemType[arraySize];
	comparisons = 0;

	for (int i = 0; i < arraySize; i++)
	{
		data[i] = items[i];
	}
}

template <class ItemType>
void QuickSorter<ItemType>::Sort()
// Function: Calls recursive function QuickSort
// Pre: an array is created to be sorted
// Post:????????
{
	QuickSort(0, arraySize - 1);
}

template <class ItemType>
ItemType* QuickSorter<ItemType>::GetData()
// Function: Returns the new sorted array
// Pre: a sorted array exisits
// Post: sorted array is returned
{
	//int size = sizeof(data) + 1;
	ItemType* temp = new ItemType[arraySize];//size

	for (int i = 0; i < arraySize; i++)
		temp[i] = data[i];

	return temp;
}

template<class ItemType>
int QuickSorter<ItemType>::GetComparisons()
// Function:
// Pre:
// Post:
{
	return comparisons;
}

template <class ItemType>
void QuickSorter<ItemType>::Split(int first, int last, int& splitPoint)
// Function: Splits the array into smaller arrays
// Pre: an array exists
// Post: array index's are split to individual arrays of 1 index each
{
	ItemType splitVal = data[first];
	int saveFirst = first;
	bool onCorrectSide;

	first++;
	do
	{
		onCorrectSide = true;
		while (onCorrectSide)
		{
			comparisons++;

			if (data[first] > splitVal)
				onCorrectSide = false;
			else
			{
				first++;
				onCorrectSide = (first <= last);
			}
		}

		onCorrectSide = (first <= last);
		while (onCorrectSide)
		{
			comparisons++;

			if (data[last] <= splitVal)
				onCorrectSide = false;
			else
			{
				last--;
				onCorrectSide = (first <= last);
			}
		}

		if (first < last)
		{
			Swap(first, last);
			first++;
			last--;
		}
	} while (first <= last);

	splitPoint = last;
	Swap(saveFirst, splitPoint);
}

template <class ItemType>
void QuickSorter<ItemType>::Swap(int index1, int index2)
// Function: Swaps index's
// Pre: an array exists
// Post: index's are swapped
{
	ItemType temp = data[index1];
	data[index1] = data[index2];
	data[index2] = temp;
}

template <class ItemType>
void QuickSorter<ItemType>::QuickSort(int first, int last)
// Function: Recursively sorts the array
// Pre: an array exists
// Post: the array is sorted
{
	if (first < last)
	{
		int splitPoint;

		Split(first, last, splitPoint);
		QuickSort(first, splitPoint - 1);
		QuickSort(splitPoint + 1, last);
	}
}

#endif